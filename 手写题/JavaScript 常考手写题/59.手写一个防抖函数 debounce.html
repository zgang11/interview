<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>防抖</title>
  </head>

  <body>
    <input type="text">
    <!-- <script>
    // https://github.com/sisterAn/JavaScript-Algorithms/issues/95
    function debounce(fn, wait = 50, immediate) {
      let timer = null
      return function (...args) {
        let context = this
        if (timer) clearTimeout(timer)

        if(immediate && !timer) {
          fn.apply(context, args)
        }
        
        if(!immediate) {
          
        } else {
         
        }

        timer = setTimeout(() => {
          fn.apply(context, args)
        }, wait)
        
      }
    }

    let betterFn = debounce(() => console.log("fn 防抖执行了"), 1000, true)
    document.addEventListener('click', betterFn)
  </script> -->

    <script>
      /**
       * 防抖函数
       * @param {Function} func - 需要防抖的函数
       * @param {number} wait - 等待时间，单位毫秒
       * @param {Object} options - 配置选项
       * @param {boolean} options.leading - 是否在触发时立即执行一次，默认false
       * @param {boolean} options.trailing - 是否在等待结束后执行一次，默认true
       * @returns {Function} 防抖后的函数
       */
      function debounce(func, wait, options = {}) {
        // 默认配置：只在最后触发执行
        const { leading = false, trailing = true } = options;

        let timer = null; // 定时器ID

        // 防抖函数的实际处理函数
        const debounced = function (...args) {
          // 如果已有定时器，清除它
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }

          // 如果需要在首次触发时执行
          if (leading && !timer) {
            func.apply(this, args);
          }

          // 设置新的定时器，用于处理最后一次触发
          if (trailing) {
            timer = setTimeout(() => {
              // 如果leading为false，则在定时器中执行（最后一次触发）
              if (!leading) {
                func.apply(this, args);
              }
              timer = null;
            }, wait);
          }
        };

        // 取消防抖函数的方法（清除定时器）
        debounced.cancel = function () {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        };

        return debounced;
      }

      // 使用示例
      // 1. 创建一个测试函数
      function handleInput(value) {
        console.log("处理输入:", value, Date.now());
      }

      // 2. 创建防抖函数：500ms内没有新触发则执行
      // 默认：只在最后一次触发后执行
      const debouncedInput = debounce(handleInput, 5000, { leading: false, trailing: true });

      // 3. 绑定到输入框事件
      const input = document.querySelector("input");
      input.addEventListener("input", (e) => {
        debouncedInput(e.target.value);
      });

      // 4. 其他配置示例
      // 首次触发立即执行，之后的触发等待结束后执行
      // const debouncedInput = debounce(handleInput, 500, { leading: true, trailing: true });

      // 只在首次触发执行，之后的触发不执行
      // const debouncedInput = debounce(handleInput, 500, { leading: true, trailing: false });
    </script>
  </body>
</html>
