<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>有并发限制的Promise.all(ts类型)</title>
  </head>
  <body>
    <!-- <script>
      function sleep(text, delay = 1000) {
        return () =>
          new Promise((resolve) => {
            setTimeout(() => {
              console.log(text);
              resolve();
            }, delay);
          });
      }

      const tasks = [1, 2, 3, 4, 5].map((i) => {
        return sleep(i);
      });

      // 方案一： 基于 async-pool 方案
      // 维护两个数组：

      // allTasks
      // poolTasks
      // 取出 tasks[i] 作为当前的任务：

      // allTasks ← task[i]
      // poolTasks ← e = task[i].then(()=>{poolTasks.splice(poolTasks.indexOf(e),1)})

      // 通过 Promise.race + await 控制 poolTasks 始终在并发数范围内，最后通过 Promise.all 实现所有任务的并发。

      const asyncPool = async (tasks, poolLimit) => {
        /* 所有异步任务执行状态 */
        const allTasks = [];
        /* 正在执行的任务数组 */
        const poolTasks = [];

        for (let i = 0; i < tasks.length; i++) {
          const curTask = Promise.resolve(tasks[i]());
          allTasks.push(curTask);

          /* 当 poolLimit <= tasks.length 时，实现并发控制 */
          if (poolLimit <= tasks.length) {
            /* 在原有异步包裹处理操作 */
            const e = curTask.then(() => {
              /* 成功后，从正在执行的任务数组中删除 */
              poolTasks.splice(poolTasks.indexOf(e), 1);
            });
            poolTasks.push(e);

            /* poolTasks 持续增加会超出限制数量 */
            if (poolTasks.length >= poolLimit) {
              /* 始终控制 poolTasks 的数量 */
              await Promise.race(poolTasks);
            }
          }
        }

        /* 此时 allTasks 中剩余 pending < poolTasks */
        return Promise.all(allTasks);
      };

      asyncPool(tasks, 2);
    </script> -->
    <script>
      /**
       * 限制并发数量的异步任务执行器
       * @param {Array<Function>} tasks 返回Promise的任务数组
       * @param {number} limit 并发限制数
       * @returns {Promise<Array>} 所有任务结果的数组
       */
      async function runWithConcurrency(tasks, limit = 3) {
        // 存储所有任务的Promise
        const results = [];
        // 使用Set来追踪正在执行的任务
        const executing = new Set();

        for (const task of tasks) {
          // 如果达到并发限制，等待任意一个任务完成
          if (executing.size >= limit) {
            await Promise.race(executing);
          }

          // 创建并执行新任务
          const p = task()
            .then((res) => {
              console.log('p', p)
              executing.delete(p); // 任务完成，从执行集合中移除
              return res;
            })
            .catch((err) => {
              executing.delete(p); // 即使失败也要移除
              throw err;
            });

          executing.add(p); // 添加到执行集合
          results.push(p); // 存储到结果数组
        }

        // 等待所有任务完成
        return Promise.all(results);
      }

      // 模拟异步请求函数
      function mockRequest(id, delay) {
        return new Promise((resolve) => {
          console.log(`请求 ${id} 开始`);
          setTimeout(() => {
            console.log(`请求 ${id} 完成`);
            resolve(`结果 ${id}`);
          }, delay);
        });
      }

      // 创建10个请求任务
      const tasks = [];
      for (let i = 1; i <= 10; i++) {
        tasks.push(() => mockRequest(i, Math.random() * 2000));
      }

      // 执行并发控制
      runWithConcurrency(tasks, 3)
        .then((results) => {
          console.log("所有请求完成:", results);
        })
        .catch((err) => {
          console.error("请求出错:", err);
        });
    </script>
  </body>
</html>
