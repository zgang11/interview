<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>手写一个节流函数 throttle</title>
  </head>

  <body>
    <div style="width: 200px; height: 10000px; background-color: red"></div>
    <!-- <script>
    // https://github.com/sisterAn/JavaScript-Algorithms/issues/92
    const throttle = (fn, wait = 50) => {
       let previos = 0
       return function(...args) {
         let now = +new Date()
         if(now - previos > wait) {
           previos = now 
           fn.apply(this, args)
         }
       }
    }
    let betterFn = throttle(() => console.log('fn 执行了'), 10000)
    setInterval(betterFn, 100);
  </script> -->

    <!-- <script>
      /**
       * 节流函数
       * @param {Function} func - 需要节流的函数
       * @param {number} wait - 节流时间间隔，单位毫秒
       * @param {Object} options - 配置选项
       * @param {boolean} options.leading - 是否在节流开始时执行一次，默认true
       * @param {boolean} options.trailing - 是否在节流结束后执行一次，默认true
       * @returns {Function} 节流后的函数
       */
      function throttle(func, wait, options = {}) {
        // 默认配置：首次触发和最后触发都执行
        const { leading = true, trailing = true } = options;

        let lastTime = 0; // 上次执行时间
        let timer = null; // 定时器ID

        // 节流函数的实际处理函数
        const throttled = function (...args) {
          const now = Date.now();

          // 如果是第一次执行，且不允许leading触发，则初始化lastTime
          if (!lastTime && leading === false) {
            lastTime = now;
          }

          // 计算距离下次允许执行的剩余时间
          const remaining = wait - (now - lastTime);

          // 如果剩余时间 <= 0，说明可以执行函数了
          if (remaining <= 0) {
            // 清除可能存在的定时器（防止trailing触发）
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }

            // 执行函数
            func.apply(this, args);
            // 更新上次执行时间
            lastTime = now;
          }
          // 如果需要最后一次触发，且当前没有定时器
          else if (trailing === true && !timer) {
            // 设置定时器，在剩余时间后执行一次
            timer = setTimeout(() => {
              func.apply(this, args);
              // 重置定时器和上次执行时间
              timer = null;
              lastTime = leading === false ? 0 : Date.now();
            }, remaining);
          }
        };

        // 取消节流函数的方法（清除定时器）
        throttled.cancel = function () {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          lastTime = 0;
        };

        return throttled;
      }

      // 使用示例
      // 1. 创建一个测试函数
      function handleScroll(e) {
        console.log("滚动事件触发", Date.now(), e);
      }

      // 2. 创建节流函数：1000ms内最多执行一次
      // 首次触发执行，最后一次触发也执行
      // const throttledScroll = throttle(handleScroll, 5000);

      // 4. 其他配置示例
      // 只在首次触发执行，最后一次不执行
      // const throttledScroll = throttle(handleScroll, 5000, { trailing: false });

      // 只在最后一次触发执行，首次不执行
      const throttledScroll = throttle(handleScroll, 5000, { leading: false });

      // 3. 绑定到滚动事件
      window.addEventListener("scroll", throttledScroll);
    </script> -->
    <script>
      // 基础节流函数：固定间隔内只执行一次
      function throttle(fn, delay) {
        let lastTime = 0; // 上次执行时间
        let timer = null; // 定时器

        return function (...args) {
          const now = Date.now(); // 当前时间
          const context = this; // 保存this指向

          // 清除之前的定时器（避免重复触发）
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }

          // 如果距离上次执行已超过间隔时间，立即执行
          if (now - lastTime >= delay) {
            fn.apply(context, args);
            lastTime = now; // 更新上次执行时间
          } else {
            // 否则，设置定时器在剩余时间后执行（确保最后一次会触发）
            timer = setTimeout(() => {
              fn.apply(context, args);
              lastTime = Date.now(); // 更新上次执行时间
              timer = null;
            }, delay - (now - lastTime));
          }
        };
      }
      // 监听滚动事件，100ms内只执行一次
      window.addEventListener(
        "scroll",
        throttle(() => {
          console.log("滚动位置：", window.scrollY);
        }, 10000)
      );
    </script>
  </body>
</html>
